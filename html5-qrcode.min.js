/** * @fileoverview 
 * Biblioteca HTML5 para leitura de código QR. * - Decodifica código QR usando webcam ou câmera de smartphone * * @author mebjas <minhazav@gmail.com > * * A palavra "QR Code" é marca registrada da DENSO WAVE INCORPORATED * http://www.denso-wave.com/qrcode/faqpatent-e.html * * Observação: ECMA Script não é compatível com todos os navegadores. Use minified/html5-qrcode.min.js para melhor * compatibilidade com navegadores. Como alternativa, o código transpilado está em transpiled/html5-qrcode.js */ 
class  Html5Qrcode { static DEFAULT_WIDTH = 300 ; static DEFAULT_WIDTH_OFFSET = 2 ; static SCAN_DEFAULT_FPS = 2 ; static MIN_QR_BOX_SIZE = 50 ; static SHADED_LEFT = 1 ; static SHADED_RIGHT = 2 ; static SHADED_TOP = 3 ; static SHADED_BOTTOM = 4 ; static SHADED_REGION_CLASSNAME = "qr-shaded-region" ; static VERBOSE = false ; static BORDER_SHADER_DEFAULT_COLOR = "#ffffff" ; static BORDER_SHADER_MATCH_COLOR = "rgb(90, 193, 56)" ;

     /** * Inicializa o leitor de código QR. * * @param {String} elementId - ID do elemento HTML. * @param {Boolean} verbose - Argumento opcional; se verdadeiro, todos os logs * serão impressos no console. */ 
    constructor (elementId, verbose) {
         if (!qrcode) {
             throw  'qrcode não está definido; use o arquivo minificado/html5-qrcode.min.js para obter suporte adequado' ; }

         this._elementId = elementId;
         this._foreverScanTimeout = null ;
         this._localMediaStream = null ;
         this._shouldScan = true ;
         this._url = window.URL || window.webkitURL || window.mozURL || window.msURL;
         this._userMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
         this._isScanning = false ; Html5Qrcode.VERBOSE = verbose === true ; }

     /** * Inicia a leitura do código QR para a câmera especificada. * * @param {String} cameraId ID da câmera a ser usada. * @param{Object} config configurações extras para ajustar o leitor de código QR. * Campos suportados: * - fps: taxa de quadros esperada da leitura do código QR. Exemplo: { fps: 2 } * significa que a leitura será feita a cada 500 ms. * - qrbox: largura da caixa de leitura do QR, que deve ser menor que * a largura e a altura da caixa. Isso fará com que o leitor * fique assim: * ---------------------- * |********************| * |******,,,,,,,,,*****| <--- região sombreada * |******| |*****| <--- a região não sombreada será * |******| |*****| usada para a leitura do código QR. * |******|_______|*****| * |********************| * |********************| * ---------------------- * @param {Function} qrCodeSuccessCallback função de retorno de chamada quando o código QR for encontrado. * Exemplo: * function(qrCodeMessage) {} * @param {Function} qrCodeErrorCallback função de retorno de chamada em caso de erro na análise do código QR. * Exemplo: * function(errorMessage) {} * * @returns Promise para iniciar a leitura. A Promise pode falhar se o usuário * não conceder permissão ou se alguma API não for suportada pelo navegador. */ 
    start(cameraId, configuration, qrCodeSuccessCallback, qrCodeErrorCallback) {
         if (!cameraId) {
             throw  "cameraId é obrigatório" ; }

         if (!qrCodeSuccessCallback || typeof qrCodeSuccessCallback != "function" ) {
             throw  "qrCodeSuccessCallback é obrigatório e deve ser uma função." 
        }

         if (!qrCodeErrorCallback) { qrCodeErrorCallback = console.log; }

         // Limpeza. 
        this._clearElement ();
         const $ this = this ;

         // Cria a configuração mesclando as configurações padrão e de entrada. 
        const config = configuration ? configuration : {}; config.fps = config.fps ? config.fps : Html5Qrcode.SCAN_DEFAULT_FPS;

         // caixa sombreada do QR Code 
        const isShadedBoxEnabled = config.qrbox != undefined;
         const element = document.getElementById( this._elementId );
         const width = element.clientWidth ? element.clientWidth : Html5Qrcode.DEFAULT_WIDTH; element.style.position = "relative" ;

         this._shouldScan = true ;
         this._element = element; qrcode.callback = qrCodeSuccessCallback;

         // Validar antes da inserção 
        if (isShadedBoxEnabled) {
             const qrboxSize = config.qrbox;
             if (qrboxSize < Html5Qrcode.MIN_QR_BOX_SIZE) {
                 throw `O tamanho mínimo de 'config.qrbox'  é de ${Html5Qrcode.MIN_QR_BOX_SIZE}px.`; }

             if (qrboxSize > width) {
                 throw  "'config.qrbox' não deve ser maior que a " 
                + "largura do elemento HTML." ; } }

         //#region métodos locais 
        /** * Configura os elementos da interface do usuário e altera o estado desta classe. * * @param width largura derivada do viewfinder. * @param height altura derivada do viewfinder. const
         setupUi = (width, height) => {
             const qrboxSize = config.qrbox;
             if (qrboxSize > height) { console.warn( "[Html5Qrcode] config.qrboxsize é maior 
                    que a altura do vídeo. O sombreamento será ignorado" ); }

             const shouldShadingBeApplied = isShadedBoxEnabled && qrboxSize <= height;
             const defaultQrRegion = { x: 0 , y: 0 , width: width, height: height };
             const qrRegion = shouldShadingBeApplied ? this ._getShadedRegionBounds(width, height, qrboxSize) : defaultQrRegion;

             const canvasElement = this ._createCanvasElement(qrRegion.width, qrRegion.height);
             const context = canvasElement.getContext( '2d' ); context.canvas.width = qrRegion.width; context.canvas.height = qrRegion.height;

             // Insere o 
            elemento canvas element.append(canvasElement);
             if (shouldShadingBeApplied) {
                 this._possiblyInsertShadingElement (element, height, qrRegion); }

             // Atualiza os estados locais 
            $ this._qrRegion = qrRegion; $ this._context = context; $ this._canvasElement = canvasElement; }

         // Método que escaneia indefinidamente. 
        const foreverScan = () => {
             if (!$ this ._shouldScan) {
                 // Parar de escanear. 
                return ; }
             if ($ this ._localMediaStream) {

                 // Há diferença entre o tamanho do vídeo renderizado e o tamanho 
                considerado pelo canvas. Precisamos levar em conta o fator de escala. 
                const videoElement = $ this ._videoElement;
                 const widthRatio = videoElement.videoWidth / videoElement.clientWidth;
                 const heightRatio = videoElement.videoHeight / videoElement.clientHeight;
                 const sWidthOffset = $ this ._qrRegion.width * widthRatio;
                 const sHeightOffset = $ this ._qrRegion.height * heightRatio;

                 // Decodifique apenas a área relevante, ignore a área sombreada. Mais informações: 
                // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage 
                $ this._context.drawImage ($ this._videoElement ,
                     /* sx= */ $ this._qrRegion.x ,
                     /* sy= */ $ this._qrRegion.y ,
                     /* sWidth= */ sWidthOffset,
                     /* sHeight= */ sHeightOffset,
                     /* dx= */  0 ,
                     /* dy= */   0 ,
                     /* dWidth= */ $ this._qrRegion.width ,
                     /* dHeight= */ $ this._qrRegion.height );
                 try { qrcode.decode();
                     this._possiblyUpdateShaders ( /* qrMatch= */  true ); } catch (exception) {
                     this._possiblyUpdateShaders ( /* qrMatch= */  false ); qrCodeErrorCallback(`Erro ao analisar o código QR, erro = ${exception}`); } } $ this._foreverScanTimeout = setTimeout(foreverScan, Html5Qrcode._getTimeoutFps(config.fps)); }

        // Função de retorno de chamada bem-sucedida quando a mídia do usuário (câmera) é conectada. 
        const onMediaStreamReceived = mediaStream => {
             return new Promise((resolve, reject) => {
                 const setupVideo = () => {
                     const videoElement = this._createVideoElement (width); $ this._element.append (videoElement);
                     // Adiciona ouvintes ao vídeo. 
                    videoElement.onabort = reject; videoElement.onerror = reject; videoElement.onplaying = () => {
                         const videoWidth = videoElement.clientWidth;
                         const videoHeight = videoElement.clientHeight; setupUi(videoWidth, videoHeight);

                         // Inicia a varredura após o início do feed de vídeo 
                        foreverScan(); resolve(); } videoElement.srcObject = mediaStream; videoElement.play();

                     // Define o estado 
                    $ this._videoElement = videoElement; } $ this._localMediaStream = mediaStream; setupVideo();

                 // TODO(mebjas): Verifique se as restrições podem ser aplicadas na câmera 
                // para melhores resultados ou desempenho. 

                // const constraints = { 
                // width: { min: width , ideal: width, max: width }, 
                // frameRate: { ideal: 30, max: 30 } 
                // } 
                // const track = mediaStream.getVideoTracks()[0]; 
                // track.applyConstraints(constraints) 
                // .then(() => setupVideo()) 
                // .catch(error => { 
                // console.log("[Warning] [Html5Qrcode] As restrições não puderam ser " 
                // + "satisfatórias, ignorando as restrições", error); 
                // setupVideo(); 
                // }); 
            }); }
         //#endregion 

        return new Promise((resolve, reject) => {
             if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                 const videoConstraints = { deviceId: { exact: cameraId } }; navigator.mediaDevices.getUserMedia( { audio: false , video: videoConstraints }) .then(stream => { onMediaStreamReceived(stream) .then(_ => { $ this ._isScanning = true; resolve(); }) . catch (reject); }) . catch (err => { reject(`Erro ao obter userMedia, erro = ${err}`); }); } else  if (navigator.getUserMedia) {
                 const getCameraConfig = { video: { optional: [{ sourceId: cameraId }] } }; navigator.getUserMedia(getCameraConfig, stream => { onMediaStreamReceived(stream) .then(_ => { $ this ._isScanning = true ; resolve(); }) . catch (reject); }, err => { reject(`Erro ao obter userMedia, erro = ${err}`); }); } else { reject( "Transmissão da webcam não é suportada pelo navegador." ); } }); }

     /** * Interrompe a transmissão e a leitura do vídeo do código QR. * * @returns Promise para fechar o fluxo de vídeo com segurança. */ 
    stop() {
         // TODO(mebjas): falhar rapidamente se start() não foi chamado. 
        this._shouldScan = false ; clearTimeout( this._foreverScanTimeout );

         const $ this = this ;
         return new Promise((resolve, /* ignorar */ reject) => { qrcode.callback = null ;
             const tracksToClose = $ this._localMediaStream.getVideoTracks ().length;
             var tracksClosed = 0 ;

             // Remove a região sombreada, se existir. 
            const removeQrRegion = () => {
                 while ($ this._element.getElementsByClassName (Html5Qrcode.SHADED_REGION_CLASSNAME).length) {
                     const shadedChild = $ this._element.getElementsByClassName (Html5Qrcode.SHADED_REGION_CLASSNAME)[ 0 ]; $ this._element.removeChild(shadedChild); } }

             const onAllTracksClosed = () => { $ this._localMediaStream = null ; $ this._element.removeChild ($ this._videoElement ); $ this._element.removeChild ($ this._canvasElement ); removeQrRegion(); $ this._isScanning = false ;
                 if ($ this._qrRegion ) { $ this._qrRegion = null ; }
                 if ($ this._context ) { $ this._context = null ; } resolve( true ); } $ this._localMediaStream.getVideoTracks ().forEach(videoTrack => { videoTrack.stop(); ++tracksClosed;

                 if (tracksClosed >= tracksToClose) { onAllTracksClosed(); } }); }); }

     /** * Analisa um arquivo de imagem em busca de um código QR. * * Este recurso é mutuamente exclusivo da leitura baseada em câmera; você deve chamar * stop() se a leitura baseada em câmera estiver em andamento. * * @param {File} imageFile um arquivo local com conteúdo de imagem. * @param {boolean} showImage se verdadeiro, a imagem será renderizada no elemento fornecido. * * @returns Promise com a string do código QR decodificado em caso de sucesso e mensagem de erro em caso de falha. * A falha pode ocorrer por diferentes motivos: * 1. A decodificação do código QR falhou porque não foram encontrados padrões suficientes na imagem. * 2. O arquivo de entrada não era uma imagem ou não foi possível carregar a imagem ou outros erros de carregamento de imagem. */ 
    scanFile(imageFile, /* padrão=true */ showImage) {
         const $ this = this ;
         if (!imageFile || !(imageFile instanceof File)) {
             throw  "O argumento imageFile é obrigatório e deve ser uma instância de " 
            + "of File. Use 'event.target.files[0]'" ; } showImage = showImage === undefined ? verdadeiro : mostrarImagem;

         se ($ this._isScanning ) {
             lançar "Feche a varredura em andamento antes de varrer um arquivo." ; }

         const computeCanvasDrawConfig = ( imageWidth, imageHeight, containerWidth, containerHeight) => {

             if (imageWidth <= containerWidth && imageHeight <= containerHeight) {
                 // não é necessário reduzir a resolução. 
                const xoffset = (containerWidth - imageWidth) / 2 ;
                 const yoffset = (containerHeight - imageHeight) / 2 ;
                 return { x: xoffset, y: yoffset, width: imageWidth, height: imageHeight }; } else {
                 const formerImageWidth = imageWidth;
                 const formerImageHeight = imageHeight;
                 if (imageWidth > containerWidth) { imageHeight = (containerWidth / imageWidth) * imageHeight; imageWidth = containerWidth; }

                 if (imageHeight > containerHeight) { imageWidth = (containerHeight / imageHeight) * imageWidth; imageHeight = containerHeight; } Html5Qrcode._log( `Imagem reduzida de ${formerImageWidth}X${formerImageHeight}` + ` para ${imageWidth}X${imageHeight}.`);

                 return computeCanvasDrawConfig( imageWidth, imageHeight, containerWidth, containerHeight); } }

         return new Promise((resolve, reject) => { $ this._possiblyCloseLastScanImageFile (); $ this._clearElement (); $ this._lastScanImageFile = imageFile;

             const inputImage = new Image; inputImage.onload = () => {
                 const imageWidth = inputImage.width;
                 const imageHeight = inputImage.height;
                 const element = document.getElementById($ this._elementId );
                 const containerWidth = element.clientWidth ? element.clientWidth : Html5Qrcode.DEFAULT_WIDTH;
                 // Sem altura padrão. 
                const containerHeight = element.clientHeight ? element.clientHeight : imageHeight;

                 constconfig = computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);
                 if (showImage) {
                     const visibleCanvas = $ this ._createCanvasElement( containerWidth, containerHeight, 'qr-canvas-visible' ); visibleCanvas.style.display = "inline-block" ; element.appendChild(visibleCanvas);
                     const context = visibleCanvas.getContext( '2d' ); context.canvas.width = containerWidth; context.canvas.height = containerHeight;
                     // Mais referências 
                    // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage 
                    context.drawImage( inputImage,
                         /* sx= */  0 ,
                         /* sy= */  0 ,
                         /* sWidth= */ imageWidth,
                         /* sHeight= */ imageHeight,
                         /* dx= */ config.x,
                         /* dy= */   config.y,
                         /* dWidth= */ config.width,
                         /* dHeight= */ config.height); }

                 const hiddenCanvas = $ this ._createCanvasElement(config.width, config.height); element.appendChild(hiddenCanvas);
                 const context = hiddenCanvas.getContext( '2d' ); context.canvas.width = config.width; context.canvas.height = config.height; context.drawImage( inputImage,
                     /* sx= */  0 ,
                     /* sy= */  0 ,
                     /* sWidth= */ imageWidth,
                     /* sHeight= */ imageHeight,
                     /* dx= */  0 ,
                     /* dy= */   0 ,
                     /* dWidth= */ config.width,
                     /* dHeight= */ config.height);
                 try { resolve(qrcode.decode()); } catch(exception) { reject(`Erro ao analisar o código QR, erro = ${exception}`); } } inputImage.onerror = reject; inputImage.onabort = reject; inputImage.onstalled = reject; inputImage.onsuspend = reject; inputImage.src = URL.createObjectURL(imageFile); }); }

     /** * Limpa a tela existente. * * Observação: no caso de uma varredura em andamento baseada em webcam, ela precisa ser explicitamente * fechada antes de chamar este método, caso contrário, lançará uma exceção. */ 
    clear() {
         this._clearElement (); }

     /** * Retorna uma Promise com a lista de todas as câmeras suportadas pelo dispositivo. * * O objeto retornado é uma lista de objetos de resultado do tipo: * [{ * id: String; // ID da câmera. * label: String; // Nome legível da câmera. * }] */ 
    static getCameras() {
         return new Promise((resolve, reject) => {
             if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices && navigator.mediaDevices.getUserMedia) {
                 this ._log( "navigator.mediaDevices usado" ); navigator.mediaDevices.getUserMedia({ audio: false , video: true }) .then(stream => {
                         // abordagem improvisada para fechar qualquer fluxo ativo, se estiverem ativos. 
                        stream.oninactive = _ => this ._log( "Todos os fluxos fechados" );
                         const closeActiveStreams = stream => {
                             const tracks = stream.getVideoTracks();
                             for ( var i = 0 ; i < tracks.length; i++) {
                                 const track = tracks[i]; track.enabled = false ; track.stop(); stream.removeTrack(track); } } navigator.mediaDevices.enumerateDevices() .then(devices => {
                                 const results = [];
                                 for ( var i = 0 ; i < devices.length; i++) {
                                     const device = devices[i];
                                     if(device.kind == "videoinput" ) { results.push({ id: device.deviceId, label: device.label }); } }
                                 this._log (`${results.length} resultados encontrados`); closeActiveStreams(stream); resolve(results); }) .catch (err => { reject(`${err.name} : ${err.message}`); }); }) .catch (err => { reject(`${err.name} : ${err.message}`); }) } else  if (MediaStreamTrack && MediaStreamTrack.getSources) {
                 this._log ( "MediaStreamTrack.getSources usado" );
                 const callback = sourceInfos => {
                     const results = [];
                     for ( var i = 0 ; i !== sourceInfos.length; ++i) {
                         const sourceInfo = sourceInfos[i];
                         if (sourceInfo.kind === 'video' ) { results.push({ id: sourceInfo.id, label: sourceInfo.label }); } }
                     this._log (`${results.length} resultados encontrados`); resolve(results); } MediaStreamTrack.getSources(callback); } else {
                 this._log ( "Não foi possível consultar dispositivos compatíveis." ); reject( "Não foi possível consultar dispositivos compatíveis." ); } }); } _clearElement() {
         if ( this._isScanning ) {
             throw  'Não é possível limpar enquanto a verificação estiver em andamento, feche-a primeiro.' ; }
         const element = document.getElementById( this._elementId ); element.innerHTML = "" ; } _createCanvasElement(largura, altura,
        customId) { const canvasWidth = largura;
         const canvasHeight = altura;
        const canvasElement = document.createElement( 'canvas' ); canvasElement.style.width = `${canvasWidth}px`; canvasElement.style.height = `${canvasHeight}px`; canvasElement.style.display = "none" ;
         // Este id é definido por lazarsoft/jsqrcode 
        canvasElement.id = customId == undefined ? 'qr-canvas' : customId;
         return canvasElement; } _createVideoElement(width) {
         const videoElement = document.createElement( 'video' ); videoElement.style.width = `${width}px`; videoElement.muted = true ; videoElement.playsInline = true ;
         return videoElement; } _getShadedRegionBounds(width, height, qrboxSize) {
         if (qrboxSize > width || qrboxSize > height) {
             throw  "'config.qrbox' não deve ser maior que a " 
            + "largura e altura do elemento HTML." ; }

         return { x: (width - qrboxSize) / 2 , y: (height - qrboxSize) / 2 , width: qrboxSize, height: qrboxSize }; } _possiblyInsertShadingElement(element, height, qrRegion) {
         if (qrRegion.x == 0 && qrRegion.y == 0 ) {
             // Sem sombreamento 
            return ; }

         const shaders = {}; shaders[Html5Qrcode.SHADED_LEFT] = this._createShadedElement (height, qrRegion, Html5Qrcode.SHADED_LEFT); shaders[Html5Qrcode.SHADED_RIGHT] = this._createShadedElement (height, qrRegion, Html5Qrcode.SHADED_RIGHT); shaders[Html5Qrcode.SHADED_TOP] = this._createShadedElement (height, qrRegion, Html5Qrcode.SHADED_TOP); shaders[Html5Qrcode.SHADED_BOTTOM] = this._createShadedElement (height, qrRegion, Html5Qrcode.SHADED_BOTTOM); Object.keys(shaders).forEach(key => element.append(shaders[key]));

         if (qrRegion.x < 10 || qrRegion.y < 10 ) {
             this .hasBorderShaders = false ; } else { Object.keys(shaders).forEach(key =>
                 this ._insertShaderBorders(shaders[key], qrRegion, key));
             this .hasBorderShaders =true ; } } _createShadedElement(height, qrRegion, shadingPosition) {
         const elem = document.createElement( 'div' ); elem.style.position = "absolute" ; elem.style.height = `${height}px`; elem.className = Html5Qrcode.SHADED_REGION_CLASSNAME; elem.id = `${Html5Qrcode.SHADED_REGION_CLASSNAME}_${shadingPosition}`
         // TODO(mebjas): maken this configurable 
        elem.style.background = `#0000007a`; switch (shadingPosition) { case Html5Qrcode.SHADED_LEFT: elem.style.top = "0px" ; elem.style.left = "0px" ; elem.style.width = `${qrRegion.x}px`; elem.style.height = `${height}px`;
                 break ; case Html5Qrcode.SHADED_RIGHT: elem.style.top = "0px" ; elem.style.right = "0px" ; elem.style.width = `${qrRegion.x}px`; elem.style.height = `${height}px`;
                 break ; case Html5Qrcode.SHADED_TOP: elem.style.top = "0px" ; elem.style.left = `${qrRegion.x}px`; elem.style.width = `${qrRegion.width}px`; elem.style.height = `${qrRegion.y}px`;
                 break ; case Html5Qrcode.SHADED_BOTTOM:
                 const top = qrRegion.y + qrRegion.height; elem.style.top = `${top}px`; elem.style.left = `${qrRegion.x}px`; elem.style.width = `${qrRegion.width}px`; elem.style.height = `${qrRegion.y}px`;
                 break ; default:
                 throw  "Posição de sombreamento não suportada" ; }

         return elem; } _insertShaderBorders(shaderElem, qrRegion, shadingPosition) { shadingPosition = parseInt(shadingPosition);
         const $ this = this ;
         const borderOffset = 5 ;
         const smallSize = 5 ;
         const largeSize = 40 ;
         const createBorder = () => {
             const elem = document.createElement( "div" ); elem.style.position = "absolute"; elem.style.backgroundColor = Html5Qrcode.BORDER_SHADER_DEFAULT_COLOR; switch (shadingPosition) { case Html5Qrcode.SHADED_LEFT:    // intencional 
                case Html5Qrcode.SHADED_RIGHT:
                     const height = largeSize + borderOffset; elem.style.width = `${smallSize}px`; elem.style.height = `${height}px`;
                     break ; case Html5Qrcode.SHADED_TOP:    // intencional 
                case Html5Qrcode.SHADED_BOTTOM:
                     const width = largeSize + borderOffset; elem.style.width = `${width}px`; elem.style.height = `${smallSize}px`;
                     break ; default:
                     throw  "Posição de sombreamento não suportada" ; }
             return elem; const

         insertBorder = (top, left) => {
             if (!(top !== null && left !== null )) {
                 throw "Os shaders devem ter posições definidas" 
            }
             const borderElem = createBorder(); borderElem.style.top = `${top}px`; borderElem.style.left = `${left}px`; shaderElem.appendChild(borderElem);

             if ( !$ this .borderShaders) { $ this .borderShaders = []; } $ this .borderShaders.push(borderElem); } let firstTop = null ; let firstLeft = null ; let secondTop = null ; let secondLeft = null ; switch (shadingPosition) { case Html5Qrcode.SHADED_LEFT: firstTop = qrRegion.y - borderOffset; firstLeft = qrRegion.x - smallSize; segundoSuperior = qrRegion.y + qrRegion.height - largeSize; segundoEsquerdo = primeiroEsquerdo;
                 break ; case Html5Qrcode.SHADED_RIGHT: primeiroSuperior = qrRegion.y - borderOffset; primeiroEsquerdo = 0 ; segundoSuperior = qrRegion.y + qrRegion.height - largeSize; segundoEsquerdo = primeiroEsquerdo;
                 break ; case Html5Qrcode.SHADED_TOP: firstTop = qrRegion.y - borderOffset; firstLeft = -smallSize; secondTop = firstTop; secondLeft = qrRegion.width - largeSize;
                 break ; case Html5Qrcode.SHADED_BOTTOM: firstTop = 0 ; firstLeft = -smallSize; secondTop = firstTop; secondLeft = qrRegion.width - largeSize;
                 break ; default:
                 throw  "Posição de sombreamento não suportada" ; } insertBorder(firstTop, firstLeft); insertBorder(secondTop, secondLeft); } _possiblyUpdateShaders(qrMatch) {
         if ( this .qrMatch === qrMatch) {
             return ; }

         if ( this .hasBorderShaders && this .borderShaders && this .borderShaders.length) {
             this .borderShaders.forEach(shader => { shader.style.backgroundColor = qrMatch ? Html5Qrcode.BORDER_SHADER_MATCH_COLOR : Html5Qrcode.BORDER_SHADER_DEFAULT_COLOR; }); }
         this .qrMatch = qrMatch; } _possiblyCloseLastScanImageFile() {
         if ( this ._lastScanImageFile) { URL.revokeObjectURL( this ._lastScanImageFile);
             this ._lastScanImageFile = null ; } } static _getTimeoutFps(fps) {
         return  1000 / fps; } static _log(message) {
         if (Html5Qrcode.VERBOSE) { console.log(message); } } }
